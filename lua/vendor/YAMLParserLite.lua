local a=string.char;local b,c=string.sub,string.gsub;local d,e=string.find,string.match;local f,g=table.insert,table.remove;local h={['0']="\x00",z="\x00",N="\x85",a="\x07",b="\x08",t="\x09",n="\x0a",v="\x0b",f="\x0c",r="\x0d",e="\x1b",['\\']='\\'}local function i(j,k)local l={}for m=0,#j do local n=j[m]if n and k(n,m)then f(l,n)end end;return l end;local function o(p)local q,r=d(p,'^%s+')if not r then return 0,p end;return r,b(p,r+1)end;local function s(t)return e(t,"^%s*(.-)$")end;local function u(t)return e(t,"^(.-)%s*$")end;local function v(p)return p==''or d(p,'^%s*$')or d(p,'^%s*#')end;local function w(x,y)return b(x,1,#y)==y end;local function z(p,y)return w(p,y)and v(b(p,#y+1))end;local A={__meta={}}function A.__meta.__call(B,...)local self=setmetatable({},B)if B.__init then B.__init(self,...)end;return self end;function A.def(C,type,B)C=C or A;local D={__metatable=C,__index=C}for E,n in pairs(C.__meta)do D[E]=n end;B=setmetatable(B or{},D)B.__index=B;B.__metatable=B;B.__type=type;B.__meta=D;return B end;local F={null=A:def('null'),map=A:def('map'),seq=A:def('seq')}local G=F.null;function G.__tostring()return'yaml.null'end;function G.isnull(n)if n==nil then return true end;if type(n)=='table'and getmetatable(n)==G then return true end;return false end;local H=G()local function I(p,J)J=J or''local K=b(p,1,1)if K==' 'or K=='\t'then return I(b(p,2))end;if K=="'"then local m=d(p,"'",2,true)if not m then return nil,p end;return b(p,2,m-1),b(p,m+1)end;if K=='"'then local m,L=2,''while m<#p do local M=b(p,m,m)if M=='\\'then local N=b(p,m+1,m+1)if h[N]~=nil then L=L..h[N]elseif N=='x'then local O=b(m+2,m+3)if d(O,'^[0-9a-fA-F]$')then L=L..a(tonumber(O,16))m=m+2 else L=L..'x'end else L=L..N end;m=m+1 elseif M==K then break else L=L..M end;m=m+1 end;return L,b(p,m+1)end;if K=='-'or K==':'then if b(p,2,2)==' 'or#p==1 then return nil,p end end;local L=''while#p>0 do local M=b(p,1,1)if d(J,M,1,true)then break elseif M==':'and(b(p,2,2)==' 'or#p==1)then break elseif M=='#'and b(L,#L,#L)==' 'then break else L=L..M end;p=b(p,2)end;return u(L),p end;local function P(n)if n=='null'or n=='Null'or n=='NULL'then return H elseif n=='true'or n=='True'or n=='TRUE'then return true elseif n=='false'or n=='False'or n=='FALSE'then return false elseif n=='.inf'or n=='.Inf'or n=='.INF'then return math.huge elseif n=='+.inf'or n=='+.Inf'or n=='+.INF'then return math.huge elseif n=='-.inf'or n=='-.Inf'or n=='-.INF'then return-math.huge elseif n=='.nan'or n=='.NaN'or n=='.NAN'then return 0/0 elseif d(n,'^[+-]?%d+%.?%d-$')or d(n,'^[+-]?%.%d+$')or d(n,'^[+-]?%d+%.?%d-[Ee][+-]?%d+$')then return tonumber(n)end;return n end;local function Q(p,R)local S={}while true do if#p==0 then if#R==0 then break else p=g(R,1)end end;local M=b(p,1,1)if M=='#'then p=''elseif M==' 'or M=='\t'or M=='\r'or M=='\n'then p=b(p,2)elseif M=='{'or M=='['then f(S,{v={},t=M})p=b(p,2)elseif M==':'then local T=g(S)f(S,{v=T.v,t=':'})p=b(p,2)elseif M==','then local U=g(S)if U.t==':'or U.t=='{'or U.t=='['then error()end;if S[#S].t==':'then local V=g(S)S[#S].v[V.v]=U.v elseif S[#S].t=='{'then S[#S].v[U.v]=true elseif S[#S].t=='['then f(S[#S].v,U.v)end;p=b(p,2)elseif M=='}'then if S[#S].t=='{'then if#S==1 then break end;S[#S].t='}'p=b(p,2)else p=','..p end elseif M==']'then if S[#S].t=='['then if#S==1 then break end;S[#S].t=']'p=b(p,2)else p=','..p end else local T,W=I(p,',{}[]')if not T then error('invalid flowstyle line: '..p)end;T=P(T)f(S,{v=T,t='s'})p=W end end;return S[1].v,p end;local function X(p,R)p=s(p)p=c(p,'%s*#.*$','')if p==''or p=='~'then return H end;if w(p,'{')or w(p,'[')then return Q(p,R)end;local T,q=I(p)if T and T~=p then return T end;if d('\'"!$',b(p,1,1),1,true)then error('unsupported line: '..p)end;if z(p,'{}')then return{}end;if z(p,'[]')then return{}end;return P(p)end;local Y;local function Z(p,R,_)local a0=setmetatable({},F.seq)if p~=''then error()end;while#R>0 do p=R[1]local a1=o(p)if a1<_ and _~=-1 then return a0 elseif a1>_ and _~=-1 then error("found bad indenting in line: "..p)end;local m,r=d(p,'%-%s+')if not m then m,r=d(p,'%-$')if not m then return a0 end end;local W=b(p,r+1)if d(W,'^[^\'\"%s]*:')then local a2=r;R[1]=string.rep(' ',a2 or 0)..W;f(a0,Y('',R,a2))elseif v(W)then g(R,1)if#R==0 then f(a0,H)return a0 end;if d(R[1],'^%s*%-')then local a3=R[1]local a2=o(a3)if a2==_ then f(a0,H)else f(a0,Z('',R,a2))end else local a3=R[1]local a2=o(a3)f(a0,Y('',R,a2))end elseif W then g(R,1)local a4=X(W,R)f(a0,a4)end end;return a0 end;function Y(p,R,_)if not v(p)then error('not map line: '..p)end;local a5=setmetatable({},F.map)while#R>0 do p=R[1]local a1,q=o(p)if a1<_ then return a5 elseif a1>_ then error("found bad indenting in line: "..p)end;local V;local T,W=I(p)if T and w(W,':')then local a6=X(T,{})if a6 and type(a6)~='string'then V=a6 else V=T end;p=b(W,2)else error("failed to classify line: "..p)end;if a5[V]~=nil then print("found a duplicate key '"..V.."' in line: "..p)local a7=1;while a5[V..'__'..a7]do a7=a7+1 end;V=V..'_'..a7 end;p=s(p)if not v(p)then g(R,1)p=s(p)a5[V]=X(p,R)else g(R,1)if#R==0 then a5[V]=H;return a5 end;if d(R[1],'^%s*%-')then local a2=o(R[1])a5[V]=Z('',R,a2)else local a2=o(R[1])if _>=a2 then a5[V]=H else a5[V]=Y('',R,a2)end end end end;return a5 end;local function a8(R)R=i(R,function(T)return not v(T)end)if#R==1 and not d(R[1],'^%s*%-')then local p=R[1]p=s(p)return X(p,R)end;local a9={}while#R>0 do local p=R[1]if d(p,'^%s*%-')then f(a9,Z('',R,-1))elseif d(p,'^%s*[^%s]')then local a1=o(p)f(a9,Y('',R,a1))else error('parse error: '..p)end end;if#a9>1 and G.isnull(a9[1])then g(a9,1)return a9 end;return a9 end;local function aa(ab)local R={}for p in string.gmatch(ab..'\n','(.-)\n')do table.insert(R,p)end;local ac=a8(R)if#ac==1 then return ac[1]end;return ac end;return{null=H,parse=aa}
